;; SPDX-License-Identifier: MIT
#include "stdlib.fc";
int equal_slices(slice s1, slice s2) asm "SDEQ";

;; Constants
const OP_ADD_ADMIN = 0x01;
const OP_MINT = 0x02;
const MAX_SUPPLY = 500;

;; Extract real sender address from internal message
slice get_sender(cell in_msg) inline {
    var cs = in_msg.begin_parse();
    cs~load_uint(1); ;; ihr_disabled
    cs~load_uint(1); ;; bounce
    cs~load_uint(1); ;; bounced
    slice sender = cs~load_msg_addr();
    return sender;
}

;; Compare addresses
(int) addr_to_bits(slice addr) inline {
    return slice_hash(addr);
}

(int) is_authorized(slice sender, slice owner, cell admins_dict) inline {
    if (equal_slices(sender, owner)) {
        return 1;
    }
    if (dict_empty?(admins_dict) == 0) {
        int key = addr_to_bits(sender);
        var (_, int found) = udict_get?(admins_dict, 256, key);
        return found;
    }
    return 0;
}

;; Add admin helper
(cell, int) add_admin(cell admins_dict, int count, slice new_admin) inline {
    int key = addr_to_bits(new_admin);
    var updated = udict_set_ref(admins_dict, 256, key, begin_cell().store_slice(new_admin).end_cell());
    return (updated, count + 1);
}

() recv_internal(int msg_value, cell in_msg, slice in_msg_body) impure {
    ;; Get sender
    slice sender = get_sender(in_msg);

    ;; Load state
    slice ds = get_data().begin_parse();
    slice owner = ds~load_msg_addr();
    int admin_count = ds~load_uint(8);
    cell admins_dict = ds~load_ref();
    int total = ds~load_uint(32);
    int next_id = ds~load_uint(32);
    cell tokens = ds~load_dict();

    ;; Operation
    int op = in_msg_body~load_uint(32);

    ;; OP_ADD_ADMIN
    if (op == OP_ADD_ADMIN) {
        if (equal_slices(sender, owner) == 0) { throw(401); }
        slice new_admin = in_msg_body~load_ref().begin_parse();
        var (new_dict, new_count) = add_admin(admins_dict, admin_count, new_admin);
        admins_dict = new_dict;
        admin_count = new_count;
    }

    ;; OP_MINT (soulbound NFT, no transfer)
    if (op == OP_MINT) {
        int auth = is_authorized(sender, owner, admins_dict);
        if (auth == 0) { throw(403); }
        if (total >= MAX_SUPPLY) { throw(410); }

        slice student = in_msg_body~load_ref().begin_parse();
        cell metadata = in_msg_body~load_ref();

        cell tok = begin_cell()
            .store_slice(student)
            .store_ref(metadata)
        .end_cell();

        tokens = udict_set_ref(tokens, 32, next_id, tok);
        total += 1;
        next_id += 1;
    }

    ;; Save updated state
    set_data(begin_cell()
        .store_slice(owner)
        .store_uint(admin_count, 8)
        .store_ref(admins_dict)
        .store_uint(total, 32)
        .store_uint(next_id, 32)
        .store_dict(tokens)
        .end_cell());

    return ();
}

;; Getter: read contract state
(slice, int, cell, int, int, cell) get_state() method_id {
    slice ds = get_data().begin_parse();
    slice owner = ds~load_msg_addr();
    int admin_count = ds~load_uint(8);
    cell admins_dict = ds~load_ref();
    int total = ds~load_uint(32);
    int next_id = ds~load_uint(32);
    cell tokens = ds~load_dict();
    return (owner, admin_count, admins_dict, total, next_id, tokens);
}